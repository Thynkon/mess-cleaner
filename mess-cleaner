#!/usr/bin/env zsh

. $HOME/dev/shell-libraries/lib_log.zsh

# Avoids expressions like 'error here | true' to be executed
set -o pipefail
# List all executed lines. Usefull for debugging
#set -o xtrace

readonly PROGRAM_NAME="mess-cleaner"
readonly PROJECT_ROOT="$HOME/dev/$PROGRAM_NAME"
readonly CONFIG_FILE="$PROJECT_ROOT/modules.conf"

class=""
# Default mode is: rename file and create a directory
mode=2

usage() {
	echo "$PROGRAM_NAME usage:\n"
	echo "-f\tFile to rename"
	echo "-h\tDisplays this message"
	echo "-m\tProgram mode"
	echo "\t\t1 - Rename file, create directory and move file"
	echo "\t\t2 - Rename file"
	echo "\t\t3 - Create directory and move file"
	echo "-r\tRename files recursively\n"
}

echoerr() {
	echo "$@" 1>&2
}

while getopts "f:hm:rv" option; do
	case "$option" in
		f)
			file_list+=($OPTARG)
			;;
		h)
			usage
			exit 0
			;;
		m)
			mode=$OPTARG
			;;

		r)
			recursive=1
			;;

		v)
			verbose_level=$(($verbose_level+1))
			;;
		*)
			usage
			exit 1
			;;
	esac
done

if [[ $recursive -eq 1 ]]; then

	# List of files that need to be renamed (relative path)
	# Grep's regex explication:
	#	find's output is something like ./0510_MandelBrot2/c_M120_p_0510_MandelBrot2_f_v1a.docx
	#	it matches the './' characters, followed by the exercice's number, name and the directory character (/)
	#	then, it seeks files that start by c_, i_ and ich_
	relative_file_list=($(find . * | grep -P ".{2}[0-9]{4}_.*\/(c|i|ich)_.*"))

	if [ ${#relative_file_list[@]} -eq 0 ]; then
		.log $LOG_INFO "No files to be renamed"
		.log $LOG_INFO "Exiting..."
		exit 0
	fi

	# Get the absolute path for each file
	for file in $relative_file_list; do
		file_list+=($(realpath $file))
	done
fi

for file in $file_list; do

	# Go to the file's directory because it is easier to rename and create directories
	cd $(dirname $file)
	
	if [[ -z "$file" ]]; then
		.log LOG_ERR "Missing options!"
		usage
		exit 1
	fi

	# Get module name from file
	# The following regex ignores any character that is before 3 numbers
	# Example: c_M120_p_0550_Panelwest_f_v1a.pdf
	# "c_M" are ignored
	module_name=$(echo "$file" | sed 's/.*[a-zA-Z_]\([0-9]\{3\}\)_.*/\1/')

	# Checks if the class entered by the user exists in the config file
	grep $module_name $CONFIG_FILE -n 1>&2 /dev/null

	if [ $? -eq 1 ]; then
		.log LOG_ERR "$module_name does not exist!"
		exit 1
	fi

	if [ ! -f "$file" ]; then
		.log LOG_ERR "File $file does not exist!"
		exit 1
	fi

	if [[ ! $mode =~ '^[1-3]$' ]]; then
		.log LOG_ERR "The mode you entered is not valid!"
		.log LOG_ERR "Enter a mode between 1 and 3"
		exit 1
	fi

	class_name="INFO"
	class_name+=$(grep $module_name $CONFIG_FILE -n | cut -f1 -d:)

	# Removes all the unwanted characters
	base_name=$(perl -pe "s/^.*(?=(_[psPS]_))//g;" -pe "s/(_f)?(_v[0-9{2}][a-z]?)?//g" <<< "$file")

	file_name="$class_name"
	file_name+="_M"
	file_name+="$module_name"
	file_name+="$base_name"

	directory_name=$(perl -pe "s/^.*(?=([0-9]{4}))//g;" -pe "s/\..*$//g" <<< "$base_name")

	case "$mode" in
		1)
			mkdir "$directory_name" && .log LOG_INFO "Directory $directory_name successfully created"
			mv $file $file_name && .log LOG_INFO "$file renamed to $file_name"
			mv $file_name $directory_name && .log LOG_INFO "$file_name moved to $directory_name"
			;;
		2)
			mv $file $file_name && .log LOG_INFO "$file renamed to $file_name"
			;;
		3)
			mkdir "$directory_name" && .log LOG_INFO "Directory $directory_name successfully created"
			mv $file $directory_name && .log LOG_INFO "$file_name moved to $directory_name"
			;;
		*)
			;;
	esac
done

.log LOG_INFO "Exiting..."

exit 0
