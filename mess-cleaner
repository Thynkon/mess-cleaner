#!/usr/bin/env zsh

readonly CURRENT_DIR=$(dirname "$0")
. "$CURRENT_DIR/shell-libraries/lib_log.zsh"

# Avoids expressions like 'error here | true' to be executed
set -o pipefail
# List all executed lines. Usefull for debugging
#set -o xtrace

readonly PROGRAM_NAME=$(basename $0)
readonly PROJECT_ROOT="$HOME/dev/$PROGRAM_NAME"
readonly CONFIG_FILE="$PROJECT_ROOT/modules.conf"

class=""
# Default mode is: rename file and create a directory
mode=2

# Directory to lookup for files that need to be renamed when using the recursive mode (-r)
dir_to_lookup="."

usage() {
	echo "$PROGRAM_NAME usage:\n"
	echo "-d directory"
	echo "\tDirectory to lookup when using the recursive mode"
	echo "\tYou should use this option with -r, otherwise it won't do anything\n"
	echo "-f filename"
	echo "\tFile to rename\n"
	echo "-h"
	echo "\tDisplays this message\n"
	echo "-m mode"
	echo "\tProgram mode"
	echo "\t1 - Rename file, create directory and move file"
	echo "\t2 - Rename file"
	echo "\t3 - Create directory and move file\n"
	echo "-r"
	echo "\tRename files recursively"
	echo "\tBy default, renames all files that are in the current currectory"
	echo "\tIf you want to rename files in other directory use the -d option\n"
}

echoerr() {
	echo "$@" 1>&2
}

while getopts "d:f:hm:rv" option; do
	case "$option" in
		d)
			recursive_mode_directory=$OPTARG
			;;

		f)
			file_list+=($OPTARG)
			;;
		h)
			usage
			exit 0
			;;
		m)
			mode=$OPTARG
			;;

		r)
			recursive=1
			;;

		v)
			verbose_level=$(($verbose_level+1))
			;;
		*)
			usage
			exit 1
			;;
	esac
done

if [[ $recursive -eq 1 ]]; then

	# List of files that need to be renamed (relative path)
	# Regex explication:
	#	find's output is something like ./0510_MandelBrot2/c_M120_p_0510_MandelBrot2_f_v1a.docx or 
	#	P_Practice/0510_MandelBrot2/c_M120_p_0510_MandelBrot2_f_v1a.docx
	#	The regex ignores the file path and matches c_M120
	#
	#	Another example:
	#	./c_Inf-M104_s_0010_Script_f_v6.pdf
	#	Ignores ./ and matches c_Inf
	relative_file_list=($(find "$dir_to_lookup" -type f -path "$dir_to_lookup/*" -regextype posix-extended -regex "(^.*(c|i|ich)_(ich|Inf|M[0-9]{3}|[0-9]{3}).*$)"))

	if [ ${#relative_file_list[@]} -eq 0 ]; then
		.log $LOG_INFO "$PROGRAM_NAME: No files to be renamed"
		.log $LOG_INFO "$PROGRAM_NAME: Exiting..."
		exit 0
	fi

	.log $LOG_INFO "$PROGRAM_NAME: ${#relative_file_list[@]} file(s) found"
	.log $LOG_INFO "$PROGRAM_NAME: $relative_file_list"

	# Get the absolute path for each file
	for file in $relative_file_list; do
		file_list+=($(realpath $file))
	done
fi

for file in $file_list; do

	# Go to the file's directory because it is easier to rename and create directories
	cd $(dirname $file)
	
	if [[ -z "$file" ]]; then
		.log $LOG_ERR "$PROGRAM_NAME: Missing options!"
		usage
		exit 1
	fi

	# Get module name from file
	# The following regex ignores any character that is before 3 numbers
	# Example: c_M120_p_0550_Panelwest_f_v1a.pdf
	# "c_M" are ignored
	module_name=$(echo "$file" | sed 's/.*[a-zA-Z_]\([0-9]\{3\}\)_.*/\1/')

	# Checks if the class entered by the user exists in the config file
	grep $module_name -q $CONFIG_FILE -n 1>&2 /dev/null

	if [ $? -eq 1 ]; then
		.log $LOG_ERR "$PROGRAM_NAME: $module_name does not exist!"
		exit 1
	fi

	if [ ! -f "$file" ]; then
		.log $LOG_ERR "$PROGRAM_NAME: File $file does not exist!"
		exit 1
	fi

	if [[ ! $mode =~ '^[1-3]$' ]]; then
		.log $LOG_ERR "$PROGRAM_NAME: The mode you entered is not valid!"
		.log $LOG_ERR "$PROGRAM_NAME: Enter a mode between 1 and 3"
		exit 1
	fi

	class_name="INFO"
	class_name+=$(grep $module_name $CONFIG_FILE -n | cut -f1 -d:)

	# Removes all the unwanted characters
	base_name=$(perl -pe "s/^.*(?=(_[epsEPS]_))//g;" -pe "s/(_f)?(_v[0-9{2}][a-z]?)?//g" <<< "$file")

	file_name="$class_name"
	file_name+="_M"
	file_name+="$module_name"
	file_name+="$base_name"

	directory_name=$(perl -pe "s/^.*(?=([0-9]{4}))//g;" -pe "s/\..*$//g" <<< "$base_name")

	case "$mode" in
		1)
			mkdir "$directory_name" && .log $LOG_INFO "$PROGRAM_NAME: Directory $directory_name successfully created"
			mv $file $file_name && .log $LOG_INFO "$PROGRAM_NAME: $file renamed to $file_name"
			mv $file_name $directory_name && .log $LOG_INFO "$PROGRAM_NAME: $file_name moved to $directory_name"
			;;
		2)
			mv $file $file_name && .log $LOG_INFO "$PROGRAM_NAME: $file renamed to $file_name"
			;;
		3)
			mkdir "$directory_name" && .log $LOG_INFO "$PROGRAM_NAME: Directory $directory_name successfully created"
			mv $file $directory_name && .log $LOG_INFO "$PROGRAM_NAME: $file_name moved to $directory_name"
			;;
		*)
			;;
	esac
done

.log $LOG_INFO "Exiting..."

exit 0
